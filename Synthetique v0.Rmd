```{r}
library(ggplot2)
library(reshape2)
library(dplyr)
library("Synth")
library(tidyverse)
library(numDeriv)
library('alabama')
```
```{r}
capital=read.csv("Statistical_Capital.csv")
croiss=read.csv("Statistical_Growth-Accounts.csv")
travail=read.csv("Statistical_Labour.csv")

compte=read.csv("Statistical_National-Accounts.csv")
description=read.csv("Variable-Description.csv")

autre_pays=read.csv("WB_data2.csv")
```
#les lignes avec des données
```{r}
lignedata=c('X1995', 'X1996', 'X1997', 'X1998', 'X1999', 'X2000', 'X2001', 'X2002', 'X2003', 'X2004', 'X2005', 'X2006', 'X2007', 'X2008', 'X2009', 'X2010', 'X2011', 'X2012', 'X2013', 'X2014', 'X2015', 'X2016', 'X2017')#les colonnes de données 
date=seq(2000, 2017)
```
#fonction qui permet de récupérer des dataframes utilisables sur une donnée
```{r}
melt_ada <- function(vari,codei){
tableau=subset(compte,(var==vari)& code==codei)[c("country", lignedata,"var")]
indligneNA <- which(is.na(tableau),arr.ind=TRUE)[,1]
tableau=tableau[-indligneNA,]
df.melted <- melt(tableau,id=c('country','var'))
df.melted$temps=as.numeric(str_sub(df.melted$variable, 2, 5))

return (df.melted[-3])
}
melt_ada('EMP','TOT')
```


```{r}
df.melted=inner_join(melt_ada('VA','TOT'),melt_ada("EMP",'TOT'),by=c("country","temps"))
df.melted$index=c(1:length((unique(df.melted$country))))
df.melted$value.x=as.numeric(df.melted$value.x)#on transtype pour permettre aux fonctions de tourner
df.melted$country=as.character(df.melted$country)
df.melted
```
#le calcul du salaire réel horaire
```{r}
df.W=inner_join(melt_ada('COMP','TOT'), melt_ada("VA_PI",'TOT'),by=c("country","temps"))
df.W=inner_join(df.W, melt_ada("H_EMPE",'TOT'),by=c("country","temps"))
df.W$index=c(1:length((unique(df.W$country))))
#on transtype pour permettre aux fonctions de tourner
df.W$country=as.character(df.W$country)
df.W$W=(df.W$value.x*100/df.W$value.y)/df.W$value
df.W$value.x=as.numeric(df.W$W)
df.W=df.W[,c('country','W', 'temps')]
df.W
```
La fusion des bases : PIB, emploi, salaire réel horaire
```{r}
df.melted2=inner_join(df.melted, df.W, by=c("country","temps"))
df.melted2$index=c(1:length((unique(df.melted2$country))))
```

###La fonction de base
```{r}
 dataprep.out=Synth::dataprep(foo=df.melted,
                predictors = c("value.x","value.y"), #Les variables utilisées en contrôle
                predictors.op = "mean", #La manière dont on les prend en compte
                time.predictors.prior = 2012, #période pré-traitement
                dependent="value.x", #variable d'intérêt
                unit.variable = "index", #colonne avec les index des pays
                unit.names.variable="country", #nom des pays
                treatment.identifier = 12, # n° de l'unité traitée
                controls.identifier = c(1:11,13:26), #n° des unités de contrôles
                time.variable = 'temps', #colonne où se trouve la date
                time.optimize.ssr = 2000:2012, #période de maximisation
                time.plot=1995:2017) #période tracée sur le graphique

synth.out <- Synth::synth(data.prep.obj = dataprep.out, method = "BFGS")

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "PIB", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")
```



```{r}
#dataprep.out$X1
dataprep.out$X0
```
###Les poids utilisés
```{r}
 synth.tables <- Synth::synth.tab(dataprep.res = dataprep.out,
 synth.res = synth.out)

synth.tables$tab.w
```

###Le calcul des poids optimaux pour l'ensemble de la période d'optimisation


Préparation des donnnées pour l'optimisation
```{r}
calculpoids=function(df.melted, value, pays='FR'){
  #préparation des données
pays_autres=max(df.melted$index)
Xt=subset(df.melted, country==pays& temps<2013 &temps>1999)
Xt=Xt[,value]#on récupère les données pour la France
Xn=Xn[Xn$country!=pays]#on récupère les autres
Xn=subset(df.melted, temps<2013 &temps>1999)
Xn=matrix(Xn[,value], nrow=pays_autres)

#la fonction d'optimisation

x0=c(rep(1/pays_autres,pays_autres))#on crée un vecteur de départ au hasard
f=function(x){norm(Xt-x%*%Xn, type="2")}
n=function(x){x}#contrainte de positivité des poids (hin(x)>0)
q=function(x){sum(x)-1}#fonction de la contrainte d'égalité (heq(x)=0)
opti=auglag(x0, f, hin=n, heq=q)#fonction d'optimisation sur toute la période
opti$par=matrix(opti$par, ncol=1)}
```
```{r}
optix=calculpoids(df.melted, 'value.x')
```
```{r}
1!=0
```


```{r}

special=list()
#Version avec les différentes dates version Synth
dataprep.out=Synth::dataprep(foo=df.melted,
                predictors.op = "mean", #La manière dont on les prend en compte
                time.predictors.prior = 2012, #période pré-traitement
                special.predictors = list(list("value.x",1999,"mean"),
                                           list("value.x",2001,"mean"),
                                           list("value.x",2003,"mean"),
                                           list("value.x",2005,"mean"),
                                           list("value.x",2007,"mean"),
                                           list("value.x",2009,"mean"),
                                           list("value.y",1999,"mean"),
                                           list("value.y",2001,"mean"),
                                           list("value.y",2003,"mean"),
                                           list("value.y",2005,"mean"),
                                           list("value.y",2007,"mean"),
                                           list("value.y",2009,"mean")
                                           ),
                dependent="value.x", #variable d'intérêt
                unit.variable = "index", #colonne avec les index des pays
                unit.names.variable="country", #nom des pays
                treatment.identifier = 12, # n° de l'unité traitée
                controls.identifier = c(1:11,13:26), #n° des unités de contrôles
                time.variable = 'temps', #colonne où se trouve la date
                time.optimize.ssr = 1999:2012, #période de maximisation
                time.plot=1995:2017) #période tracée sur le graphique

synth.out <- Synth::synth(data.prep.obj = dataprep.out, method = "BFGS")

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "PIB", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")

#Version sans les différentes dates
dataprep.out=Synth::dataprep(foo=df.melted,
                predictors = c("value.x","value.y"), #Les variables utilisées en contrôle
                predictors.op = "mean", #La manière dont on les prend en compte
                time.predictors.prior = 2012, #période pré-traitement
                dependent="value.x", #variable d'intérêt
                unit.variable = "index", #colonne avec les index des pays
                unit.names.variable="country", #nom des pays
                treatment.identifier = 12, # n° de l'unité traitée
                controls.identifier = c(1:11,13:26), #n° des unités de contrôles
                time.variable = 'temps', #colonne où se trouve la date
                time.optimize.ssr = 1999:2012, #période de maximisation
                time.plot=1995:2017) #période tracée sur le graphique
synth.out <- Synth::synth(data.prep.obj = dataprep.out, method = "BFGS")

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "PIB", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")
#version a la mano
synth.out$solution.w=optix#on remplace les poids par ceux calculés

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "PIB", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")
```

```{r}
 synth.tables <- Synth::synth.tab(dataprep.res = dataprep.out,
 synth.res = synth.out)

synth.tables$tab.w
```
###Pour l'emploi
```{r}
optiy=calculpoids(df.melted, 'value.y')
```

```{r}
dataprep.out=Synth::dataprep(foo=df.melted,
                predictors = c("value.x","value.y"), #Les variables utilisées en contrôle
                predictors.op = "mean", #La manière dont on les prend en compte
                time.predictors.prior = 2012, #période pré-traitement
                dependent="value.y", #variable d'intérêt
                unit.variable = "index", #colonne avec les index des pays
                unit.names.variable="country", #nom des pays
                treatment.identifier = 12, # n° de l'unité traitée
                controls.identifier = c(1:11,13:26), #n° des unités de contrôles
                time.variable = 'temps', #colonne où se trouve la date
                time.optimize.ssr = 2000:2012, #période de maximisation
                time.plot=1995:2017) #période tracée sur le graphique

synth.out <- Synth::synth(data.prep.obj = dataprep.out, method = "BFGS")

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "Emploi", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")

dataprep.out=Synth::dataprep(foo=df.melted,
                predictors.op = "mean", #La manière dont on les prend en compte
                time.predictors.prior = 2012, #période pré-traitement
                special.predictors = list(list("value.x",1999,"mean"),
                                           list("value.x",2001,"mean"),
                                           list("value.x",2003,"mean"),
                                           list("value.x",2005,"mean"),
                                           list("value.x",2007,"mean"),
                                           list("value.x",2009,"mean"),
                                           list("value.y",1999,"mean"),
                                           list("value.y",2001,"mean"),
                                           list("value.y",2003,"mean"),
                                           list("value.y",2005,"mean"),
                                           list("value.y",2007,"mean"),
                                           list("value.y",2009,"mean")
                                           ),
                dependent="value.y", #variable d'intérêt
                unit.variable = "index", #colonne avec les index des pays
                unit.names.variable="country", #nom des pays
                treatment.identifier = 12, # n° de l'unité traitée
                controls.identifier = c(1:11,13:26), #n° des unités de contrôles
                time.variable = 'temps', #colonne où se trouve la date
                time.optimize.ssr = 1999:2012, #période de maximisation
                time.plot=1995:2017) #période tracée sur le graphique

synth.out <- Synth::synth(data.prep.obj = dataprep.out, method = "BFGS")

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "Emploi", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")

synth.out$solution.w=optiy#on remplace les poids par ceux calculés

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "Emploi", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")
```


```{r}
 synth.tables <- Synth::synth.tab(dataprep.res = dataprep.out,
 synth.res = synth.out)

synth.tables$tab.w
synth.tables$tab.v
```



###Une fonction pour afficher le contrôle synthétique avec la fonction de base, celle en s'apesantissant sur les poids et celle en calculant les poids à part
```{r}
tripleSynth=function(liste_value, df.melt, pays='FR'){
#calcul des poids :
opti=calculpoids(df.melt, liste_value[1], pays)
special=list()
###création d'une liste pour les prédicteurs spéciaux
year=seq(1999,2012,2)
for(i in liste_value ){
  for (j in date){
    if(i=='value.x'&j==1999){liste=list(list(i,j, "mean"))}
    else{liste=c(liste, list(list(i, j, "mean")))}
  }
}
liste=as.list(liste)
ind_pays=which(df.melted2$country==pays)[1]
#Version avec les différentes dates version Synth
dataprep.out=Synth::dataprep(foo=df.melt,
                predictors.op = "mean", #La manière dont on les prend en compte
                time.predictors.prior = 2012, #période pré-traitement
                special.predictors = liste,
                dependent=liste_value[1], #variable d'intérêt
                unit.variable = "index", #colonne avec les index des pays
                unit.names.variable="country", #nom des pays
                treatment.identifier = ind_pays, # n° de l'unité traitée
                controls.identifier = c(1:max(df.melted2$index))[-ind_pays], #n° des unités de contrôles
                time.variable = 'temps', #colonne où se trouve la date
                time.optimize.ssr = 1999:2012, #période de maximisation
                time.plot=1995:2017) #période tracée sur le graphique

synth.out <- Synth::synth(data.prep.obj = dataprep.out, method = "BFGS")

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "PIB", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")

#Version sans les différentes dates
dataprep.out=Synth::dataprep(foo=df.melt,
                predictors = liste_value, #Les variables utilisées en contrôle
                predictors.op = "mean", #La manière dont on les prend en compte
                time.predictors.prior = 2012, #période pré-traitement
                dependent=liste_value[1], #variable d'intérêt
                unit.variable = "index", #colonne avec les index des pays
                unit.names.variable="country", #nom des pays
                treatment.identifier = ind_pays, # n° de l'unité traitée
                controls.identifier = c(1:max(df.melted2$index))[-ind_pays], #n° des unités de contrôles
                time.variable = 'temps', #colonne où se trouve la date
                time.optimize.ssr = 1999:2012, #période de maximisation
                time.plot=1995:2017) #période tracée sur le graphique
synth.out <- Synth::synth(data.prep.obj = dataprep.out, method = "BFGS")

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "PIB", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")
#version a la mano
synth.out$solution.w=opti#on remplace les poids par ceux calculés

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "PIB", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")
}
tripleSynth(liste_value=c("value.x", "value.y", "W"), df.melted2, pays='FR')
```



