

```{r}
library(ggplot2)
library(reshape2)
library(dplyr)
library("Synth")
library(tidyverse)
library(numDeriv)
library('alabama')
library("rgenoud")
```

```{r}
capital=read.csv("Statistical_Capital.csv")
croiss=read.csv("Statistical_Growth-Accounts.csv")
travail=read.csv("Statistical_Labour.csv")

compte=read.csv("Statistical_National-Accounts.csv")
description=read.csv("Variable-Description.csv")

autre_pays=read.csv("WB_data2.csv")
pays2lettres=read.csv('liste_pays_2lettres.csv')
pays3lettres=read.csv('liste_pays_3lettres.csv')
codepays=read.csv("codes_pays.csv")
```
#les lignes avec des données
```{r}
lignedata=c('X1995', 'X1996', 'X1997', 'X1998', 'X1999', 'X2000', 'X2001', 'X2002', 'X2003', 'X2004', 'X2005', 'X2006', 'X2007', 'X2008', 'X2009', 'X2010', 'X2011', 'X2012', 'X2013', 'X2014', 'X2015', 'X2016', 'X2017')#les colonnes de données 
date=seq(2000, 2017)
```


```{r}
codepays=codepays %>% rename( country=ISO2.digit.Alpha)
comptebis=left_join(compte,codepays,by="country")
compte=comptebis%>% rename(country3L=ISO3.digit.Alpha)

capitalbis=left_join(capital,codepays,by="country")
capital=capitalbis%>% rename(country3L=ISO3.digit.Alpha)

croissbis=left_join(croiss,codepays,by="country")
croiss=croissbis%>% rename(country3L=ISO3.digit.Alpha)
```

#fonction qui permet de récupérer des dataframes utilisables sur une donnée
```{r}
melt_ada <- function(vari,codei,basei=compte,tps=lignedata){
tableau=subset(basei,(var==vari)& code==codei)[c("country3L", tps,"var")]
indligneNA <- which(is.na(tableau),arr.ind=TRUE)[,1]
tableau=tableau[-indligneNA,]
df.melted <- melt(tableau,id=c('country3L','var'))
df.melted$temps=as.numeric(str_sub(df.melted$variable, 2, 5))
df.melted$country=as.character(df.melted$country3L)
return (df.melted[-3]%>% select(-country3L))
}
```


```{r}
df.melted=inner_join(melt_ada('VA','TOT'),melt_ada("EMP",'TOT'),by=c("country","temps"))
df.melted$index=c(1:length((unique(df.melted$country))))
df.melted$value.x=as.numeric(df.melted$value.x)#on transtype pour permettre aux fonctions de tourner
df.melted$country=as.character(df.melted$country)
df.melted=inner_join(df.melted, melt_ada("LP_QI","TOT"), by=c("country","temps"))
df.melted=inner_join(df.melted, melt_ada("LAB","TOT",croiss), by=c("country","temps"))
df.melted
```

```{r}
df.melted=df.melted%>% rename(VA=value.x,Emploi=value.y,Productivite=value.x.x,LAB=value.y.y)
```

#le calcul du salaire réel horaire
```{r}
df.W=inner_join(melt_ada('COMP','TOT'), melt_ada("VA_PI",'TOT'),by=c("country","temps"))
df.W=inner_join(df.W, melt_ada("H_EMPE",'TOT'),by=c("country","temps"))
df.W$index=c(1:length((unique(df.W$country))))
df.W$country=as.character(df.W$country)
df.W$W=(df.W$value.x*100/df.W$value.y)*1000/df.W$value#le nombre d'heures travaillées est en milliers
df.W$VA=as.numeric(df.W$W)
df.W=df.W[,c('country','W', 'temps')]
```


#La fusion des bases : PIB, emploi, salaire réel horaire, productivité
```{r}
df.melted2=inner_join(df.melted, df.W, by=c("country","temps"))
df.melted2$index=c(1:length((unique(df.melted2$country))))
df.melted2
```
```{r}
df.scale<-df.melted2
df.scale$Emploi<-scale(df.melted2$Emploi)
df.scale$VA<-scale(df.melted2$VA)
df.scale$W<-scale(df.melted2$W)
```
```{r}
tableau=subset(capital,(var=='Iq_GFCF')& code=='TOT')[c("country3L", lignedata[8:21],"var")]
indligneNA <- which(is.na(tableau),arr.ind=TRUE)[,1]
tableau=tableau[indligneNA,]
tableau
```


#Intégration de la population
```{r}
df.melted2=df.melted2[c("country",'temps','index','VA','Emploi','W','Productivite','LAB')]
dfpop=subset(autre_pays,Simple.Indicator=="pop")[c("Country.Code","Simple.Indicator",lignedata)]
rownames(dfpop)<-dfpop[,1]
head(dfpop[-c(1,2)])
```

```{r}
df_pop<-t(dfpop[-c(1,2)])
df <- data.frame(x=1995:2017, data.frame(df_pop))
df.pop <- melt(df, id="x")%>%rename(country=variable, temps=x,pop=value)
```

#Intégration du taux de chomage et exportations
```{r}
dfchom=subset(autre_pays,Simple.Indicator=="unemployment rate")[c("Country.Code","Simple.Indicator",lignedata)]
rownames(dfchom)<-dfchom[,1]
dfexports=subset(autre_pays,Simple.Indicator=="exports_hab")[c("Country.Code","Simple.Indicator",lignedata)]
rownames(dfexports)<-dfexports[,1]
```
```{r}
df_chom<-t(dfchom[-c(1,2)])
df <- data.frame(x=1995:2017, data.frame(df_chom))
df.chom <- melt(df, id="x")%>%rename(country=variable, temps=x,chomage=value)
df_exp<-t(dfexports[-c(1,2)])
df <- data.frame(x=1995:2017, data.frame(df_exp))
df.exp <- melt(df, id="x")%>%rename(country=variable, temps=x,export=value)
```

```{r}
df.melted2=left_join(df.melted2,df.chom)
df.melted2=left_join(df.melted2,df.pop)
df.melted2=left_join(df.melted2,df.exp)

```
```{r}
df.melted2$VA_pop=df.melted2$VA/df.melted2$pop*1000000
df.melted2$Part_lab=df.melted2$LAB/df.melted2$VA
df.melted2
```
#Investissement
```{r}
df.invest=melt_ada('Iq_GFCF','TOT',capital,tps=lignedata[5:22])
df.melted_i=inner_join(df.melted2,df.invest,by=c("country","temps"))
df.melted_i$index=c(1:length((unique(df.melted_i$country))))
df.melted_i
```


###La fonction de base
```{r}
 dataprep.out=Synth::dataprep(foo=df.melted2,
                predictors = c("VA_pop","Emploi","W","Productivite","chomage","Part_lab"), #Les variables utilisées en contrôle
                predictors.op = "mean", #La manière dont on les prend en compte
                time.predictors.prior = 2012, #période pré-traitement
                dependent="Emploi", #variable d'intérêt
                unit.variable = "index", #colonne avec les index des pays
                unit.names.variable="country", #nom des pays
                treatment.identifier = 10, # n° de l'unité traitée
                controls.identifier = c(1:9,11:21), #n° des unités de contrôles
                time.variable = 'temps', #colonne où se trouve la date
                time.optimize.ssr = 2000:2012, #période de maximisation
                time.plot=1995:2017, ) #période tracée sur le graphique

synth.out <- Synth::synth(data.prep.obj = dataprep.out, method = "BFGS")

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "PIB", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")
synth.out$solution.v
synth.out$solution.w
```



```{r}
#dataprep.out$X1
dataprep.out$X0
```
###Les poids utilisés
```{r}
 synth.tables <- Synth::synth.tab(dataprep.res = dataprep.out,
 synth.res = synth.out)

synth.tables$tab.w
```


###Le calcul des poids optimaux pour l'ensemble de la période d'optimisation


Préparation des donnnées pour l'optimisation
```{r}
quiet <- function(x) { 
  sink(tempfile()) 
  on.exit(sink()) 
  invisible(force(x)) 
} 

```

```{r}
calculpoids=function(df.melted, value, pays='FRA'){
  #préparation des données
pays_autres=length(c(table(df.melted$country)))-1
Xt=subset(df.melted, country==pays& temps<2013 &temps>1999)
Xt=Xt[,value]#on récupère les données pour la France

Xn=subset(df.melted, temps<2013 &temps>1999)
Xn=Xn[Xn$country!=pays,]#on récupère les autres
Xn=matrix(Xn[,value], nrow=pays_autres)

#la fonction d'optimisation

x0=c(rep(1/pays_autres,pays_autres))#on crée un vecteur de départ au hasard
f=function(x){norm(Xt-x%*%Xn, type="2")}
n=function(x){x}#contrainte de positivité des poids (hin(x)>0)
q=function(x){sum(x)-1}#fonction de la contrainte d'égalité (heq(x)=0)
opti=quiet(auglag(x0, f, hin=n, heq=q))#fonction d'optimisation sur toute la période
opti$par=matrix(opti$par, ncol=1)}
```
```{r}
optix=calculpoids(df.melted, 'VA')
```


```{r}
gen_liste=function(liste_value)
{
a=0
year=seq(1999,2012,2)
for(i in liste_value ){
  for (j in year){
    a=a+1
    if(a==1){liste=list(list(i,j, "mean"))}
    
    else{liste=c(liste, list(list(i, j, "mean")))  }
  }
}
liste=as.list(liste)

return(liste)
}
```


```{r}
special=list()
#Version avec les différentes dates version Synth
dataprep.out=Synth::dataprep(foo=df.melted2,
                predictors.op = "mean", #La manière dont on les prend en compte
                time.predictors.prior = 2012, #période pré-traitement
                special.predictors = gen_liste(c("VA_pop","Emploi","W","Productivite")),
                dependent="VA_pop", #variable d'intérêt
                unit.variable = "index", #colonne avec les index des pays
                unit.names.variable="country", #nom des pays
                treatment.identifier = 10, # n° de l'unité traitée
                controls.identifier = c(1:9,11:21), #n° des unités de contrôles
                time.variable = 'temps', #colonne où se trouve la date
                time.optimize.ssr = 1999:2012, #période de maximisation
                time.plot=1995:2017) #période tracée sur le graphique

synth.out <- Synth::synth(data.prep.obj = dataprep.out, method = "BFGS")

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "PIB", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")
```


```{r}
#Version sans les différentes dates
dataprep.out=Synth::dataprep(foo=df.melted,
                predictors = c("VA","Emploi"), #Les variables utilisées en contrôle
                predictors.op = "mean", #La manière dont on les prend en compte
                time.predictors.prior = 2012, #période pré-traitement
                dependent="VA", #variable d'intérêt
                unit.variable = "index", #colonne avec les index des pays
                unit.names.variable="country", #nom des pays
                treatment.identifier = 11, # n° de l'unité traitée
                controls.identifier = c(1:10,12:22), #n° des unités de contrôles
                time.variable = 'temps', #colonne où se trouve la date
                time.optimize.ssr = 1999:2012, #période de maximisation
                time.plot=1995:2017) #période tracée sur le graphique
synth.out <- Synth::synth(data.prep.obj = dataprep.out, method = "BFGS")

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "PIB", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")
#version a la mano
synth.out$solution.w=optix#on remplace les poids par ceux calculés

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "PIB", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")
```


```{r}
 synth.tables <- Synth::synth.tab(dataprep.res = dataprep.out,synth.res = synth.out)

synth.tables$tab.w
```
###Pour l'emploi
```{r}
optiy=quiet(calculpoids(df.melted, 'Emploi'))
```

```{r}
dataprep.out=Synth::dataprep(foo=df.melted,
                predictors = c("VA","Emploi"), #Les variables utilisées en contrôle
                predictors.op = "mean", #La manière dont on les prend en compte
                time.predictors.prior = 2012, #période pré-traitement
                dependent="Emploi", #variable d'intérêt
                unit.variable = "index", #colonne avec les index des pays
                unit.names.variable="country", #nom des pays
                treatment.identifier = 11, # n° de l'unité traitée
                controls.identifier = c(1:10,12:22), #n° des unités de contrôles
                time.variable = 'temps', #colonne où se trouve la date
                time.optimize.ssr = 2000:2012, #période de maximisation
                time.plot=1995:2017) #période tracée sur le graphique

synth.out <- Synth::synth(data.prep.obj = dataprep.out, method = "BFGS")

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "Emploi", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")

dataprep.out=Synth::dataprep(foo=df.melted2,
                predictors.op = "mean", #La manière dont on les prend en compte
                time.predictors.prior = 2012, #période pré-traitement
                special.predictors = list(list("VA",1999,"mean"),
                                           list("VA",2001,"mean"),
                                           list("VA",2003,"mean"),
                                           list("VA",2005,"mean"),
                                           list("VA",2007,"mean"),
                                           list("VA",2009,"mean"),
                                           list("Emploi",1999,"mean"),
                                           list("Emploi",2001,"mean"),
                                           list("Emploi",2003,"mean"),
                                           list("Emploi",2005,"mean"),
                                           list("Emploi",2007,"mean"),
                                           list("Emploi",2009,"mean")
                                           ),
                dependent="Emploi", #variable d'intérêt
                unit.variable = "index", #colonne avec les index des pays
                unit.names.variable="country", #nom des pays
                treatment.identifier = 11, # n° de l'unité traitée
                controls.identifier = c(1:10,12:22), #n° des unités de contrôles
                time.variable = 'temps', #colonne où se trouve la date
                time.optimize.ssr = 1999:2012, #période de maximisation
                time.plot=1995:2017) #période tracée sur le graphique

synth.out <- Synth::synth(data.prep.obj = dataprep.out, method = "BFGS")

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "Emploi", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")

synth.out$solution.w=optiy#on remplace les poids par ceux calculés

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "Emploi", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")
```



```{r}
 synth.tables <- Synth::synth.tab(dataprep.res = dataprep.out,
 synth.res = synth.out)

synth.tables$tab.w
synth.tables$tab.v
```



###Une fonction pour afficher le contrôle synthétique avec la fonction de base, celle en s'apesantissant sur les poids et celle en calculant les poids à part
```{r}
tripleSynth=function(liste_value, df.melt, pays='FRA'){
#calcul des poids :
opti=calculpoids(df.melt, liste_value[1], pays)
special=list()
###création d'une liste pour les prédicteurs spéciaux
year=seq(1999,2012,2)

gen_liste(liste_value)
ind_pays=which(df.melt$country==pays)[1]
#Version avec les différentes dates version Synth
dataprep.out=Synth::dataprep(foo=df.melt,
                predictors.op = "mean", #La manière dont on les prend en compte
                time.predictors.prior = 2012, #période pré-traitement
                special.predictors = gen_liste(liste_value),
                dependent=liste_value[1], #variable d'intérêt
                unit.variable = "index", #colonne avec les index des pays
                unit.names.variable="country", #nom des pays
                treatment.identifier = ind_pays, # n° de l'unité traitée
                controls.identifier = c(1:max(df.melt$index))[-ind_pays], #n° des unités de contrôles
                time.variable = 'temps', #colonne où se trouve la date
                time.optimize.ssr = 1999:2012, #période de maximisation
                time.plot=1995:2017) #période tracée sur le graphique

synth.out <- Synth::synth(data.prep.obj = dataprep.out, method = "BFGS")

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "PIB", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")

#Version sans les différentes dates
dataprep.out=Synth::dataprep(foo=df.melt,
                predictors = liste_value, #Les variables utilisées en contrôle
                predictors.op = "mean", #La manière dont on les prend en compte
                time.predictors.prior = 2012, #période pré-traitement
                dependent=liste_value[1], #variable d'intérêt
                unit.variable = "index", #colonne avec les index des pays
                unit.names.variable="country", #nom des pays
                treatment.identifier = ind_pays, # n° de l'unité traitée
                controls.identifier = c(1:max(df.melt$index))[-ind_pays], #n° des unités de contrôles
                time.variable = 'temps', #colonne où se trouve la date
                time.optimize.ssr = 2005:2012, #période de maximisation
                time.plot=1995:2017) #période tracée sur le graphique
synth.out <- Synth::synth(data.prep.obj = dataprep.out, method = "BFGS")

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "PIB", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")
#version a la mano
synth.out$solution.w=opti#on remplace les poids par ceux calculés

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "PIB", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")
}
tripleSynth(liste_value=c("VA", "Emploi", "W"), df.melted2, pays='FRA')
```

```{r}
df.melted_i$Invest_pop=df.melted_i$value/df.melted_i$pop
df.melted_i
```

```{r}
df.melted_i$Emploi_scale<-scale(df.melted_i$Emploi)

variable=c("Invest_pop","W","VA_pop","Productivite","export","Part_lab","Emploi_scale")
df.melted_i$Emploi_scale<-scale(df.melted_i$Emploi)

indice_sans=function(base)
{
 df_exo=filter(df.melted_i, country !='ITA' & country !='DEU')
 a=unique(df_exo$index) 
 a=a[a!=10]
 return(a)  
}

a=indice_sans(df.melted_i)
b=c(1:9,11:21)

dataprep.out=Synth::dataprep(foo=df.melted_i,
                predictors = (variable),#Les variables utilisées en contrôle
                predictors.op = "mean", #La manière dont on les prend en compte
                time.predictors.prior = c(2000:2011), #période pré-traitement
                dependent="Emploi", #variable d'intérêt
                unit.variable = "index", #colonne avec les index des pays
                unit.names.variable="country", #nom des pays
                treatment.identifier = 10, # n° de l'unité traitée
                controls.identifier = a, #n° des unités de contrôles
                time.variable = 'temps', #colonne où se trouve la date
                time.optimize.ssr = 2000:2005, #période de maximisation
                time.plot=1999:2016, ) #période tracée sur le graphique

synth.out <- Synth::synth(data.prep.obj = dataprep.out, method = c("BFGS"),custom.v=c(1/12,1/12,1/12,1/12,5/12,1/12,1/12))

Synth::path.plot(synth.res = synth.out, dataprep.res = dataprep.out,
Ylab = "PIB", Xlab = "year", Legend = c("France", "synthetic France"), Legend.position = "bottomright")

synth.tables <- Synth::synth.tab(dataprep.res = dataprep.out,
 synth.res = synth.out)

synth.tables$tab.w
synth.tables$tab.v
```

###Tentative en normalisant###


```{r}
value='VA'
pays='FRA'
pays_autres=length(c(table(df.melted$country)))-1
Xt=subset(df.melted, country==pays& temps<2013 &temps>1999)
Xt=Xt[,value]
Xt=scale(Xt)#on récupère les données pour la France

Xn=subset(df.melted, temps<2013 &temps>1999)
Xn=Xn[Xn$country!=pays,]#on récupère les autres
Xn=matrix(Xn[,value], nrow=pays_autres)
Xnorm=t(scale(t(Xn)))#on normalise les données par pays(la normalisation se fait par colonne)
Xt=Xt[1:13]
```


#calcul des poids
```{r}
x0=c(rep(1/pays_autres,pays_autres))#on crée un vecteur de départ au hasard
f=function(x){norm(Xt-x%*%Xnorm, type="2")}
n=function(x){x}#contrainte de positivité des poids (hin(x)>0)
q=function(x){sum(x)-1}#fonction de la contrainte d'égalité (heq(x)=0)
opti=quiet(auglag(x0, f, hin=n, heq=q))#fonction d'optimisation sur toute la période
opti$par=matrix(opti$par, ncol=1)
```

#plot des résultats
```{r}
Xt=subset(df.melted, country==pays)
Xt=Xt[,value]
Xn=subset(df.melted)
Xn=Xn[Xn$country!=pays,]#on récupère les autres
Xn=matrix(Xn[,value], nrow=pays_autres)
Xnorm=t(scale(t(Xn)))#on normalise les données par pays(la normalisation se fait par colonne)

plot(c(t(opti$par)%*%Xnorm*sd(c(Xt))+mean(c(Xt))))
plot(Xt)

```
```{r}
opti$par
```

```{r}
mean(c(Xt))
sd(c(Xt))
```











